\documentclass[12pt]{article}

\usepackage{float}
\usepackage[caption = false]{subfig}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[hidelinks]{hyperref}
\graphicspath{{data/}}

\usepackage{xcolor}
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
 
\lstset{style=mystyle}

\textheight 23.2 cm

\textwidth 6.0 in

\hoffset = -0.5 in

\voffset = -2.4 cm

\hyphenation{}

\frenchspacing

\title{
\large Introduction to image processing and computer vision \\
\LARGE \textbf{Plant Segmentation and Labeling} \\
Laboratory Project I
}

\author{Martin Mrugała}

\begin{document}

\maketitle
\newpage
\tableofcontents

\thispagestyle{empty}

\newpage

\clearpage
\pagenumbering{arabic}

\section{Introduction}

\paragraph{
The goal of the project is to prepare a solution for segmentation and further labeling of plants for given dataset. Here is the Wikipedia’s definition of image segmentation: In computer vision, image segmentation is the process of partitioning a digital image into multiple segments (sets of pixels, also known as image objects). The goal of segmentation is to simplify and/or change the representation of an image into something that is more meaningful and easier to analyze. Image segmentation is typically used to locate objects and boundaries (lines, curves, etc.) in images. More precisely, image segmentation is the process of assigning a label to every pixel in an image such that pixels with the same label share certain characteristics. The dataset contains 900 images of 5 plants that are taken using 3 cameras. For each picture the mask of the plant has to be created first. The second step is to label the growing leaves.
}


\includegraphics[width = 2.7in]{label_00_00_000_00.png}
\label{kej}
\includegraphics[width = 2.7in]{label_00_00_000_0011.png}

\hspace{1cm}
\includegraphics[width = 2.7in]{rgb_00_00_009_05.png}
\label{key}
\includegraphics[width = 2.7in]{label_00_00_009_05.png}

\newpage
\subsection{Project Description}

\subparagraph{
The first important thing is that all leaves are green. The masks creation is based on segmentation which in this case is done by setting properly ranges for pixels’ values. Moreover, morphological transformations are applied. \\\\
}

List of files :
\begin{itemize}
\item mask.py - creates the best (relatively) masks for the plant images 
\item label.py - creates labelled masks for given binary masks
\end{itemize}

\newpage

\section{Algorithm description}


\subsection{Creating binary masks}

We begin with the first file, namely mask.py. Everything happens in main two for loops which traverse the directory with plant images. Before the loops the default values are set.

\begin{lstlisting}[language=Python]
counter=0
sumJacc=0
sumDice=0

bhMin=0
bsMin=0
bvMin=0
bhMax=179
bsMax=255
bvMax=255
bkernelx=1
bkernely=1
bitin=1
bitex=1

for root, dirs, files in os.walk("C:/Users/martin/Desktop/Vision/multi_plant"):
for filename in files:
\end{lstlisting}
\vspace{5mm}
 By modifying the three variables called filename2, filename3 and filename3 one can set the paths for the directory containing the photos of plants, labelled masks which can be transformed into ideal masks and destination of new masks, respectively. 
\vspace{5mm}
\begin{lstlisting}[language=Python]
filename2="C:/Users/martin/Desktop/Vision/multi_plant/"+filename
filename3="C:/Users/martin/Desktop/Vision/multi_label/label_"+filename[4:]
filename4="C:/Users/martin/Desktop/Vision/multi_mask/label_"+filename[4:]
\end{lstlisting}
\vspace{5mm}
\newpage
Next, the name of the processed image is printed in the console.\\\\
\begin{lstlisting}[language=Python]
print(filename)
\end{lstlisting}
\vspace{5mm}
Moving forward, the ideal mask is obtained from the label image. In order to do that the function getLabelMask is used. This function consists of few lines. There is color conversion from BGR to grayscale. This is needed to set a threshold which changes the various colors to white. 
\vspace{5mm}
\begin{lstlisting}[language=Python]
label_mask=getLabelMask(label_mask)
hsv = cv2.cvtColor(originalImage, cv2.COLOR_BGR2HSV)
\end{lstlisting}
\vspace{5mm}
After that the masks are checked with the tryMasks function. The function contains 4 for loops which check parameters within given ranges. The step is added in order to optimize the algorithm. 
\vspace{5mm}
\begin{lstlisting}[language=Python]
def tryMasks(label_mask,hsv,hMin,hMinE,sMin,
sMinE,hMax,hMaxE,vMax,vMaxE,step,
kernelx,kernely,itin,itex):
	exactness=0.0
	for hn in range(hMin,hMinE,step):
		for sn in range(sMin,sMinE,step):
			for hx in range(hMax,hMaxE,step):
				for vx in range(vMax,vMaxE,step):
\end{lstlisting}
\vspace{5mm}
The mask are computed with getMask function. The morphology functions improve the image by removing some of the disturbances.\\
\newpage
Morphological transformations are some simple operations based on the image shape. It is normally performed on binary images. It needs two inputs, one is our original image, second one is called structuring element or kernel which decides the nature of operation. Two basic morphological operators are Erosion and Dilation. Then its variant forms like Opening and Closing. For example, having a picture:\\
\begin{center}
\includegraphics[width = 1.5in]{2.jpg}
\end{center}
The morphological transformations with given some parameters give the following results:\\
Erosion:\\
\begin{center}
	\includegraphics[width = 1.5in]{3.jpg}
\end{center}
Dilation:\\
\begin{center}
	\includegraphics[width = 1.5in]{4.jpg}
\end{center}
\newpage
Opening:\\
\begin{center}
	\includegraphics[width = 3in]{5.jpg}
\end{center}
Closing:\\
\begin{center}
	\includegraphics[width = 3in]{6.jpg}
\end{center}
\vspace{5mm}
\begin{lstlisting}[language=Python]
def getMask(mask,kernelx,kernely,itin,itex):
	height , width = mask . shape [:2]
	mask = cv2 . dilate( mask , np . ones ((kernelx , kernely ) ,
	np . uint8 ),iterations=itex )
	mask = cv2 . erode( mask , np . ones ((kernelx , kernely ) ,
	np . uint8 ),iterations=itin)           
	mask = cv2 . morphologyEx ( mask , cv2 . MORPH_OPEN ,
	np . ones ((kernelx , kernely ) , np . uint8 ))
	mask = cv2 . morphologyEx ( mask , cv2 . MORPH_CLOSE ,
	np . ones ((kernelx , kernely ) , np . uint8 ))
	mask = cv2 . medianBlur ( mask , 5)
\end{lstlisting}
\vspace{5mm}
\newpage
The functions findContours returns an array with contours of the image. The biggest one is chosen and drawn on the image. This procedure removes all other things in the picture. It is done by sorting the contours in descending order by area and selecting the first one.
\vspace{5mm}
\begin{center}
	\includegraphics[width = 3in]{7.jpg}
\end{center}
\begin{center}
	\includegraphics[width = 3in]{8.jpg}
\end{center}
\begin{lstlisting}[language=Python]
cnts,_= cv2.findContours(mask,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)

if not cnts:
	ret,mask=cv2.threshold(mask,0,255,cv2.THRESH_BINARY)
	return mask

c = sorted(cnts, key = cv2.contourArea, reverse = True)[0]
mask = cv2 . drawContours ( np . zeros (( height , width ,1) ,
np . uint8) , [ c ] , 0 , [255 ,255 ,255] , cv2 . FILLED )
ret,mask=cv2.threshold(mask,0,255,cv2.THRESH_BINARY)
return mask
\end{lstlisting}
\newpage
Of course there can be other green thing bigger than the plant in the picture. The second possibility is that one stem or more are removed and the leaves are not connected.\\

\begin{center}
	\includegraphics[width = 3in]{9.jpg}
\end{center}
\begin{center}
	\includegraphics[width = 3in]{10.jpg}
\end{center}
The tests are used to find the best fitting mask to the ideal mask. The Jaccardi index and dice coefficient are computed. \\
\begin{lstlisting}[language=Python]
JaccardiIndex=jaccardiIndex(mask,label_mask)
if JaccardiIndex>exactness:
exactness=JaccardiIndex
hMinR=hn
sMinR=sn
vMaxR=vx
hMaxR=hx
\end{lstlisting}
\newpage
The test functions are quite simple. They implements the formulas given in the project description:
\vspace{5mm}

\begin{lstlisting}[language=Python]
def jaccardiIndex(mask,label_mask):
	intersection = cv2.bitwise_and(mask,label_mask)
	union = cv2.bitwise_or(mask,label_mask)
	return intersection.sum()/union.sum()
\end{lstlisting}
\vspace{5mm}
\begin{lstlisting}[language=Python]
def diceCoefficient(image1,image2):
	im1 = np.asarray(image1).astype(np.bool)
	im2 = np.asarray(image2).astype(np.bool)

	if im1.shape != im2.shape:
		raise ValueError("Shape mismatch: image 1 and image 2 must have the same shape.")

	intersection = np.logical_and(im1, im2)
	return 2. * intersection.sum() / (im1.sum() + im2.sum())
\end{lstlisting}
\vspace{5mm}
The algorithm main part starts with step equal to 10 and given intervals.
\vspace{5mm}
\begin{lstlisting}[language=Python]
step=10
JaccardiIndex,bhMin,bsMin,bhMax,bvMax =tryMasks(
label_mask,hsv.copy(),
30,56,25,66,65,86,225,256,step,
bkernelx,bkernely,
bitin,bitex)
\end{lstlisting}
\vspace{5mm}
Later, the result for the intervals [ x – step + 1 ; x + 10 ] with a new step are checked ( where the x is the solution for previous range and step ).
\vspace{5mm}
\begin{lstlisting}[language=Python]
JaccardiIndex,bhMin,bsMin,bhMax,bvMax =tryMasks(
label_mask,hsv.copy(),
bhMin-step+1,bhMin+step,
bsMin-step+1,bsMin+step,
bhMax-step+1,bhMax+step,
bvMax-step+1,bvMax+step,5,
bkernelx,bkernely,
bitin,bitex)

step=5
\end{lstlisting}
\vspace{5mm}
The sequence of steps is as follows: 10,5,3,2,1. In this way we get the best parameters.\\
The best mask is computed and saved in the appropriate directory.
\vspace{5mm}
\begin{lstlisting}[language=Python]
mask=getMask(cv2.inRange(hsv, lower, upper),bkernelx,bkernely,bitin,bitex)
dice=diceCoefficient(mask,label_mask)
cv2.imwrite(filename4,mask)
\end{lstlisting}
\vspace{5mm}
The last part of the code computes the average Jaccardi index and dice coefficient. The results are printed in the console. 
\vspace{5mm}
\begin{lstlisting}[language=Python]
sumJacc=sumJacc+JaccardiIndex
sumDice=sumDice+dice
counter=counter+1
print('Jaccardi index')
print(JaccardiIndex)
print('Dice coefficient')
print(dice)
print('Average Jaccardi index')
print(sumJacc/counter)
print('Average dice coefficient')
print(sumDice/counter)
\end{lstlisting}
\newpage
\subsection{Creating labelled masks}

\vspace{5mm}
Having computed the masks one should pay attention to the second file, label.py. This code is responsible for creating the labelled masks. The algorithm is capable to detect only 4 leaves. This means that there are at most 4 colors.\\
The beginning is similar to this in the first file. After setting the default values one can find 2 for loops traversing the directory with previously created masks. The two – filename2 and filename3 – variables contains the paths to the directories where new labelled masks should be stored and where ideal labelled masks reside, respectively. 
\vspace{5mm}
\begin{lstlisting}[language=Python]
counter=1
sumJacc=0
sumDice=0
for root, dirs, files in os.walk("C:/Users/martin/Desktop/Vision/multi_mask"):
for filename in files:

filename2="C:/Users/martin/Desktop/Vision/labels/"+filename
filename3="C:/Users/martin/Desktop/Vision/multi_label/"+filename
\end{lstlisting}
\vspace{5mm}
The if statement checks if the image represents a first image of growing plant. It occurs every 60 photos so simple counter ( which is used for tests further ) and modulo operator are sufficient to deal with this obstacle. 
\vspace{5mm}
\begin{lstlisting}[language=Python]
if (counter%60)==1:
	imageC=prepareInitialImage(image.copy(),counter)
	cv2.imwrite(filename2,imageC)
	filename4=filename2
	counter=counter+1
	continue
\end{lstlisting}
\vspace{5mm}
There is the prepareInitialImage in this if statement. It is quite complex. 
\vspace{5mm}
\begin{lstlisting}[language=Python]
imageC=prepareInitialImage(image.copy(),counter)
\end{lstlisting}
\vspace{5mm}
The prepareImage function is the same as in the previous file. The function looks for the contours in the mask. Of course the output is the mask of the plant. The contour is needed for computation the center of the plant. This argument assumes that is it the average of the extreme points. The function findContourCenter computes the coordinates.
\vspace{5mm}
\begin{lstlisting}[language=Python]
def findContourCenter(contour):
	leftmost = tuple(contour[contour[:,:,0].argmin()][0])
	rightmost = tuple(contour[contour[:,:,0].argmax()][0])
	topmost = tuple(contour[contour[:,:,1].argmin()][0])
	bottommost = tuple(contour[contour[:,:,1].argmax()][0])
	x=(leftmost[0]+rightmost[0])/2
	y=(topmost[1]+bottommost[1])/2
	return int(x),int(y)
\end{lstlisting}
\vspace{5mm}
Next, a black line going trough the center is drawn. It divides the plant into two parts which are the leaves. One may notice that at the beginning every plant consists of exactly 2 leaves. 
\vspace{5mm}
\begin{lstlisting}[language=Python]
cv2.line(imageC, (x-counter,y-20), (x+10,y+10), (0,0,0), 2)
\end{lstlisting}
\vspace{5mm}
That is why the if statement at the very beginning of the function exists. There are two cases for which the default slope of the line does not divide the plant into two parts.
\vspace{5mm}
\begin{lstlisting}[language=Python]
if counter==721:
	counter=5
elif counter==241:
	counter=20
else:
	counter=15
\end{lstlisting}
\vspace{5mm}
The centers of the leaves are computed. It is because the algorithm divides the image into 4 abstract regions. The leaf is colored with a color designated for given region ( the color is returned by the getColour function).
\vspace{5mm}
\begin{lstlisting}[language=Python]
def getColour(centerX,centerY,x,y):
	if x>=centerX:
		if y>=centerY:
			color=[255,255,0]
		else:
			color=[0,255,0]
	else:
		if y>=centerY:
			color=[255,0,0]
		else:
			color=[0,0,255]
	return color
\end{lstlisting}
\vspace{5mm}
 The line, however, is not colored. This code snippet is responsible for locating the line and coloring the place with appropriate color.
\vspace{5mm}
\begin{lstlisting}[language=Python]
pix = np.any(imageC != [0, 0, 0], axis=-1)
imageC2=image.copy()
imageC2[pix]=[0,0,0]
pix = np.any(imageC2 != [0, 0, 0], axis=-1)
imageC[pix]=getColour(x,y,x1,y1)
\end{lstlisting}\vspace{5mm}
After this the initial image is stored in the right directory. 
\vspace{5mm}
\begin{lstlisting}[language=Python]
cv2.imwrite(filename2,imageC)
\end{lstlisting}\vspace{5mm}
Filename4 is the path to the previous mask.
\vspace{5mm}
This line finds pixels with any color in the previous mask.
\begin{lstlisting}[language=Python]
pixels_mask = np.any(image2 == [255,255,255], axis=-1)
\end{lstlisting}\vspace{5mm}
The next one finds, in turn, all black pixels in the current mask. 
\vspace{5mm}
\begin{lstlisting}[language=Python]
pixels_mask2 = np.any(image == [0,0,0], axis=-1)
\end{lstlisting}
\vspace{5mm}
The pixels that were colored in the previous mask are colored with the black color. In this way the image contains only contours that represent the parts that grew.
\vspace{5mm}
\begin{lstlisting}[language=Python]
imageCopy[pixels_mask] = 0
\end{lstlisting}
\vspace{5mm}
It is possible that a pixel that was colored in the previous labelled mask is black in the current one. This code line makes it black.
\vspace{5mm}
\begin{lstlisting}[language=Python]
imageC[pixels_mask2]=[0,0,0]
\end{lstlisting}
\vspace{5mm}
The contours that are the parts that grew are colored with appropriate colors.
\vspace{5mm}
\begin{lstlisting}[language=Python]
for element in cnt:
	x2,y2=findContourCenter(element)
	imageC = cv2 . drawContours ( 
	imageC, [ element ] , 0 ,
	getColour(x,y,x2,y2) , cv2 . FILLED )
\end{lstlisting}
\vspace{5mm}
The new labelled mask is stored in the right directory.
\vspace{5mm}
\begin{lstlisting}[language=Python]
cv2.imwrite(filename2,imageC)
filename4=filename2
\end{lstlisting}
\vspace{5mm}
At the end the tests are executed. The functions jaccardiIndex and diceCoefficient are the same as in the previous file but the approach is a little bit different. They are computed for times each. This is because the values are computed for each color. The segmentations are done “manually” instead of using arrays, because there are only 4 possible colors.
\vspace{5mm}
\begin{lstlisting}[language=Python]
def doTests(myLabel,original):
	lower = np.array([255, 0, 0])
	upper = np.array([255, 0, 0])
	lower2 = np.array([0, 255, 0])
	upper2 = np.array([0, 255, 0])
	lower3 = np.array([0, 0, 255])
	upper3 = np.array([0, 0, 255])
	lower4 = np.array([255, 255, 0])
	upper4 = np.array([255, 255, 0])

	myLabel1=cv2.inRange(myLabel.copy(), lower, upper)
	original1=cv2.inRange(original.copy(), lower, upper)
	myLabel2=cv2.inRange(myLabel.copy(), lower2, upper2)
	original2=cv2.inRange(original.copy(), lower2, upper2)
	myLabel3=cv2.inRange(myLabel.copy(), lower3, upper3)
	original3=cv2.inRange(original.copy(), lower3, upper3)
	myLabel4=cv2.inRange(myLabel.copy(), lower4, upper4)
	original4=cv2.inRange(original.copy(), lower4, upper4)

	JaccardiIndex=0
	DiceCoefficient=0

	JaccardiIndex=JaccardiIndex+jaccardiIndex(myLabel1,original1)
	DiceCoefficient=DiceCoefficient+diceCoefficient(myLabel1,original1)
	JaccardiIndex2=JaccardiIndex+jaccardiIndex(myLabel2,original2)
	DiceCoefficient2=DiceCoefficient+diceCoefficient(myLabel2,original2)
	JaccardiIndex3=JaccardiIndex+jaccardiIndex(myLabel3,original3)
	DiceCoefficient3=DiceCoefficient+diceCoefficient(myLabel3,original3)
	JaccardiIndex4=JaccardiIndex+jaccardiIndex(myLabel4,original4)
	DiceCoefficient4=DiceCoefficient+diceCoefficient(myLabel4,original4)
\end{lstlisting}
\vspace{5mm}
\begin{lstlisting}[language=Python]
idealLabel=cv2.imread(filename3)
JaccardiIndex,dice=doTests(imageC,idealLabel)
sumJacc=sumJacc+JaccardiIndex
sumDice=sumDice+dice
print('Jaccardi index')
print(JaccardiIndex)
print('Dice coefficient')
print(dice)
print('Average Jaccardi index')
print(sumJacc/counter)
print('Average dice coefficient')
print(sumDice/counter)
counter=counter+1
\end{lstlisting}
\section{Results}
The background is unfavourable sometimes. That is why the masks are not ideal, unfortunately. The set of binary masks has the accuracy for Jaccardi index approximately 90.8\% and for the dice coefficient – 95.1\%. For labelled masks the numbers look much worse. Jaccardi index is at 31.5\% and dice coeffieint at 36.9\%.  This is because the algorithm is able to detect only 4 colors. Moreover, the created masks are not ideal.\\
The truth is that one could manipulate the morphological transformations. The program is adapted to do that but the default implementation is quite simple. That is because in case of many big for loops my computer computes the 900 binary mask within 15 hours or even more. It could give only few per cent accuracy more, which is relatively not very much, and is very time-consuming. The optimization with steps is quite efficient and fast.\\
In case of labelling I implemented the idea of dividing the whole image at the center of the plant into 4 subregions. Of course it could be done better but this way works


\section{Source Code}
\subsection{mask.py}
\begin{lstlisting}[language=Python]
import numpy as np
import cv2
import os

def diceCoefficient(image1,image2):
im1 = np.asarray(image1).astype(np.bool)
im2 = np.asarray(image2).astype(np.bool)

if im1.shape != im2.shape:
raise ValueError("Shape mismatch: image 1 and image 2 must have the same shape.")

intersection = np.logical_and(im1, im2)
return 2. * intersection.sum() / (im1.sum() + im2.sum())

def getMask(mask,kernelx,kernely,itin,itex):
height , width = mask . shape [:2]
mask = cv2 . dilate( mask , np . ones ((kernelx , kernely ) ,
np . uint8 ),iterations=itex )
mask = cv2 . erode( mask , np . ones ((kernelx , kernely ) ,
np . uint8 ),iterations=itin)           
mask = cv2 . morphologyEx ( mask , cv2 . MORPH_OPEN ,
np . ones ((kernelx , kernely ) , np . uint8 ))
mask = cv2 . morphologyEx ( mask , cv2 . MORPH_CLOSE ,
np . ones ((kernelx , kernely ) , np . uint8 ))
mask = cv2 . medianBlur ( mask , 5)
cnts,_= cv2.findContours(mask,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)

if not cnts:
ret,mask=cv2.threshold(mask,0,255,cv2.THRESH_BINARY)
return mask

c = sorted(cnts, key = cv2.contourArea, reverse = True)[0]
mask = cv2 . drawContours ( np . zeros (( height , width ,1) ,
np . uint8) , [ c ] , 0 , [255 ,255 ,255] , cv2 . FILLED )
ret,mask=cv2.threshold(mask,0,255,cv2.THRESH_BINARY)
return mask

def jaccardiIndex(mask,label_mask):
intersection = cv2.bitwise_and(mask,label_mask)
union = cv2.bitwise_or(mask,label_mask)
return intersection.sum()/union.sum()

def getLabelMask(image):
image=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
ret,image=cv2.threshold(image,0,255,cv2.THRESH_BINARY)
return image

def tryMasks(label_mask,hsv,hMin,hMinE,sMin,
sMinE,hMax,hMaxE,vMax,vMaxE,step,
kernelx,kernely,itin,itex):
exactness=0.0
for hn in range(hMin,hMinE,step):
for sn in range(sMin,sMinE,step):
for hx in range(hMax,hMaxE,step):
for vx in range(vMax,vMaxE,step):
lower = np.array([hn, sn, 0])
upper = np.array([hx, 255, vx])
mask=getMask(cv2.inRange(hsv, lower, upper),kernelx,kernely,itin,itex)
JaccardiIndex=jaccardiIndex(mask,label_mask)
if JaccardiIndex>exactness:
exactness=JaccardiIndex
hMinR=hn
sMinR=sn
vMaxR=vx
hMaxR=hx
return exactness,hMinR,sMinR,hMaxR,vMaxR



counter=0
sumJacc=0
sumDice=0

bhMin=0
bsMin=0
bvMin=0
bhMax=179
bsMax=255
bvMax=255
bkernelx=1
bkernely=1
bitin=1
bitex=1

for root, dirs, files in os.walk("C:/Users/martin/Desktop/Vision/multi_plant"):
for filename in files:

filename2="C:/Users/martin/Desktop/Vision/multi_plant/"+filename
filename3="C:/Users/martin/Desktop/Vision/multi_label/label_"+filename[4:]
filename4="C:/Users/martin/Desktop/Vision/multi_mask/label_"+filename[4:]

originalImage = cv2.imread(filename2)
label_mask=cv2.imread(filename3,cv2.IMREAD_COLOR)
height , width = originalImage . shape [:2]
print(filename)


label_mask=getLabelMask(label_mask)
hsv = cv2.cvtColor(originalImage, cv2.COLOR_BGR2HSV)


step=10
JaccardiIndex,bhMin,bsMin,bhMax,bvMax =tryMasks(
label_mask,hsv.copy(),
30,56,25,66,65,86,225,256,step,
bkernelx,bkernely,
bitin,bitex)


JaccardiIndex,bhMin,bsMin,bhMax,bvMax =tryMasks(
label_mask,hsv.copy(),
bhMin-step+1,bhMin+step,
bsMin-step+1,bsMin+step,
bhMax-step+1,bhMax+step,
bvMax-step+1,bvMax+step,5,
bkernelx,bkernely,
bitin,bitex)

step=5

JaccardiIndex,bhMin,bsMin,bhMax,bvMax =tryMasks(
label_mask,hsv.copy(),
bhMin-step+1,bhMin+step,
bsMin-step+1,bsMin+step,
bhMax-step+1,bhMax+step,
bvMax-step+1,bvMax+step,3,
bkernelx,bkernely,
bitin,bitex)

step=3

JaccardiIndex,bhMin,bsMin,bhMax,bvMax =tryMasks(
label_mask,hsv.copy(),
bhMin-step+1,bhMin+step,
bsMin-step+1,bsMin+step,
bhMax-step+1,bhMax+step,
bvMax-step+1,bvMax+step,2,
bkernelx,bkernely,
bitin,bitex)

step=2

JaccardiIndex,bhMin,bsMin,bhMax,bvMax =tryMasks(
label_mask,hsv.copy(),
bhMin-step+1,bhMin+step,
bsMin-step+1,bsMin+step,
bhMax-step+1,bhMax+step,
bvMax-step+1,bvMax+step,1,
bkernelx,bkernely,
bitin,bitex)

lower = np.array([bhMin, bsMin, bvMin])
upper = np.array([bhMax, bsMax, bvMax])

mask=getMask(cv2.inRange(hsv, lower, upper),bkernelx,bkernely,bitin,bitex)
dice=diceCoefficient(mask,label_mask)
cv2.imwrite(filename4,mask)
sumJacc=sumJacc+JaccardiIndex
sumDice=sumDice+dice
counter=counter+1
print('Jaccardi index')
print(JaccardiIndex)
print('Dice coefficient')
print(dice)
print('Average Jaccardi index')
print(sumJacc/counter)
print('Average dice coefficient')
print(sumDice/counter)
\end{lstlisting}
\subsection{label.py}
\begin{lstlisting}[language=Python]
import numpy as np
import cv2
import os

def doTests(myLabel,original):
lower = np.array([255, 0, 0])
upper = np.array([255, 0, 0])
lower2 = np.array([0, 255, 0])
upper2 = np.array([0, 255, 0])
lower3 = np.array([0, 0, 255])
upper3 = np.array([0, 0, 255])
lower4 = np.array([255, 255, 0])
upper4 = np.array([255, 255, 0])

myLabel1=cv2.inRange(myLabel.copy(), lower, upper)
original1=cv2.inRange(original.copy(), lower, upper)
myLabel2=cv2.inRange(myLabel.copy(), lower2, upper2)
original2=cv2.inRange(original.copy(), lower2, upper2)
myLabel3=cv2.inRange(myLabel.copy(), lower3, upper3)
original3=cv2.inRange(original.copy(), lower3, upper3)
myLabel4=cv2.inRange(myLabel.copy(), lower4, upper4)
original4=cv2.inRange(original.copy(), lower4, upper4)

JaccardiIndex=0
DiceCoefficient=0

JaccardiIndex=JaccardiIndex+jaccardiIndex(myLabel1,original1)
DiceCoefficient=DiceCoefficient+diceCoefficient(myLabel1,original1)
JaccardiIndex2=JaccardiIndex+jaccardiIndex(myLabel2,original2)
DiceCoefficient2=DiceCoefficient+diceCoefficient(myLabel2,original2)
JaccardiIndex3=JaccardiIndex+jaccardiIndex(myLabel3,original3)
DiceCoefficient3=DiceCoefficient+diceCoefficient(myLabel3,original3)
JaccardiIndex4=JaccardiIndex+jaccardiIndex(myLabel4,original4)
DiceCoefficient4=DiceCoefficient+diceCoefficient(myLabel4,original4)

return JaccardiIndex,DiceCoefficient


def jaccardiIndex(mask,label_mask):
intersection = cv2.bitwise_and(mask,label_mask)
union = cv2.bitwise_or(mask,label_mask)
return intersection.sum()/union.sum()

def diceCoefficient(image1,image2):
im1 = np.asarray(image1).astype(np.bool)
im2 = np.asarray(image2).astype(np.bool)

if im1.shape != im2.shape:
raise ValueError("Shape mismatch: image 1 and image 2 must have the same shape.")

intersection = np.logical_and(im1, im2)
return 2. * intersection.sum() / (im1.sum() + im2.sum())

def findContourCenter(contour):
leftmost = tuple(contour[contour[:,:,0].argmin()][0])
rightmost = tuple(contour[contour[:,:,0].argmax()][0])
topmost = tuple(contour[contour[:,:,1].argmin()][0])
bottommost = tuple(contour[contour[:,:,1].argmax()][0])
x=(leftmost[0]+rightmost[0])/2
y=(topmost[1]+bottommost[1])/2
return int(x),int(y)
def prepareImage(image):
image=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
ret,imageCopy=cv2.threshold(image,0,255,cv2.THRESH_BINARY)
return image

def prepareInitialImage(image,counter):
if counter==721:
counter=5
elif counter==241:
counter=20
else:
counter=15

imageC=prepareImage(image.copy())
contour,_= cv2.findContours(imageC,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
x,y=findContourCenter(contour[0])
cv2.line(imageC, (x-counter,y-20), (x+10,y+10), (0,0,0), 2)
contour,_= cv2.findContours(imageC,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
imageC=cv2.cvtColor(imageC,cv2.COLOR_GRAY2BGR)
x1,y1=findContourCenter(contour[0])
x2,y2=findContourCenter(contour[1])
imageC= cv2 . drawContours ( imageC, [ contour[0] ] , 0 , getColour(x,y,x1,y1) , cv2 . FILLED )
imageC = cv2 . drawContours ( imageC, [ contour[1] ] , 0 , getColour(x,y,x2,y2) , cv2 . FILLED )
pix = np.any(imageC != [0, 0, 0], axis=-1)
imageC2=image.copy()
imageC2[pix]=[0,0,0]
pix = np.any(imageC2 != [0, 0, 0], axis=-1)
imageC[pix]=getColour(x,y,x1,y1)
return imageC

def getColour(centerX,centerY,x,y):
if x>=centerX:
if y>=centerY:
color=[255,255,0]
else:
color=[0,255,0]
else:
if y>=centerY:
color=[255,0,0]
else:
color=[0,0,255]
return color


counter=1
sumJacc=0
sumDice=0
for root, dirs, files in os.walk("C:/Users/martin/Desktop/Vision/multi_mask"):
for filename in files:

filename2="C:/Users/martin/Desktop/Vision/labels/"+filename
filename3="C:/Users/martin/Desktop/Vision/multi_label/"+filename
print(filename)
filename="C:/Users/martin/Desktop/Vision/multi_mask/"+filename
image=cv2.imread(filename)

if (counter%60)==1:
imageC=prepareInitialImage(image.copy(),counter)
cv2.imwrite(filename2,imageC)
filename4=filename2
counter=counter+1
continue

image2=cv2.imread(filename4)
imageC=image2.copy()
imageCopy=prepareImage(image.copy())

cnt2,_= cv2.findContours(imageCopy,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
x,y=findContourCenter(cnt2[0])

pixels_mask = np.any(image2 == [255,255,255], axis=-1)
pixels_mask2 = np.any(image == [0,0,0], axis=-1)

imageCopy[pixels_mask] = 0

cnt,_= cv2.findContours(imageCopy,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
imageC[pixels_mask2]=[0,0,0]

for element in cnt:
x2,y2=findContourCenter(element)
imageC = cv2 . drawContours ( 
imageC, [ element ] , 0 ,
getColour(x,y,x2,y2) , cv2 . FILLED )


cv2.imwrite(filename2,imageC)
filename4=filename2

idealLabel=cv2.imread(filename3)
JaccardiIndex,dice=doTests(imageC,idealLabel)
sumJacc=sumJacc+JaccardiIndex
sumDice=sumDice+dice
print('Jaccardi index')
print(JaccardiIndex)
print('Dice coefficient')
print(dice)
print('Average Jaccardi index')
print(sumJacc/counter)
print('Average dice coefficient')
print(sumDice/counter)
counter=counter+1
\end{lstlisting}

\newpage

\section{References}

\begin{enumerate}
\item \url{https://en.wikipedia.org/wiki/Image\_segmentation}
\item
\url{https://docs.opencv.org/2.4/doc/tutorials/imgproc/erosion_dilatation/erosion_dilatation.html}
\item
\url{https://docs.opencv.org/}

\end{enumerate}

\end{document}